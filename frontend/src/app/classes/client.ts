/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://bande-dessinee-fr.oups.net/api/";
    }

    /**
     * @param password (optional) 
     * @param database (optional) 
     * @param offset (optional) 
     * @return Success
     */
    async admin(password: string | undefined, database: string | undefined, offset: number | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Admin?";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (database === null)
            throw new Error("The parameter 'database' cannot be null.");
        else if (database !== undefined)
            url_ += "database=" + encodeURIComponent("" + database) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processAdmin(_response);
    }

    protected async processAdmin(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async login(body: AuthenticateUtilisateur | undefined): Promise<AuthenticationResponse> {
        let url_ = this.baseUrl + "/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processLogin(_response);
    }

    protected async processLogin(response: Response): Promise<AuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<AuthenticationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async register(body: CreateUtilisateur | undefined): Promise<AuthenticationResponse> {
        let url_ = this.baseUrl + "/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processRegister(_response);
    }

    protected async processRegister(response: Response): Promise<AuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<AuthenticationResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async refresh(body: RefreshUtilisateur | undefined): Promise<AuthenticationResponse> {
        let url_ = this.baseUrl + "/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processRefresh(_response);
    }

    protected async processRefresh(response: Response): Promise<AuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<AuthenticationResponse>(<any>null);
    }

    /**
     * @param page (optional) 
     * @return Success
     */
    async movieGetPage(page: number | undefined): Promise<PaginationMovie> {
        let url_ = this.baseUrl + "/Movie?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Authorization": "Bearer" + localStorage.getItem("token"),
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processMovie(_response);
    }

    protected async processMovie(response: Response): Promise<PaginationMovie> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationMovie.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<PaginationMovie>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async movieCreate(body: CreateMoviesAndPublisher | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Movie";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processMovie2(_response);
    }

    protected async processMovie2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    async movieGetById(id: number): Promise<Movies> {
        let url_ = this.baseUrl + "/Movie/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processMovie3(_response);
    }

    protected async processMovie3(response: Response): Promise<Movies> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Movies.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<Movies>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async movieUpdate(id: number, body: CreateMovies | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Movie/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processMovie4(_response);
    }

    protected async processMovie4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    async movie5(id: number): Promise<void> {
        let url_ = this.baseUrl + "/Movie/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processMovie5(_response);
    }

    protected async processMovie5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param page (optional) 
     * @return Success
     */
    async publisher(page: number | undefined): Promise<PaginationPublisher> {
        let url_ = this.baseUrl + "/Publisher?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processPublisher(_response);
    }

    protected async processPublisher(response: Response): Promise<PaginationPublisher> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationPublisher.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<PaginationPublisher>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async publisher2(body: CreatePublishers | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Publisher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processPublisher2(_response);
    }

    protected async processPublisher2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    async publisher3(id: number): Promise<Publishers> {
        let url_ = this.baseUrl + "/Publisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processPublisher3(_response);
    }

    protected async processPublisher3(response: Response): Promise<Publishers> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Publishers.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<Publishers>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async publisher4(id: number, body: CreatePublishers | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Publisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processPublisher4(_response);
    }

    protected async processPublisher4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    async publisher5(id: number): Promise<void> {
        let url_ = this.baseUrl + "/Publisher/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processPublisher5(_response);
    }

    protected async processPublisher5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }


    async utilisateur(): Promise<Utilisateur> {
        let url_ = this.baseUrl + "/Utilisateur";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token"),
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processUtilisateur(_response);
    }

    protected async processUtilisateur(response: Response): Promise<Utilisateur> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Utilisateur.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<Utilisateur>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    async utilisateurUpdate(body: Utilisateur | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Utilisateur";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token"),
                "Content-Type": "application/json",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processUtilisateur2(_response);
    }

    protected async processUtilisateur2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param authorization (optional) 
     * @return Success
     */
    async utilisateurDelete(): Promise<void> {
        let url_ = this.baseUrl + "/Utilisateur";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Authorization": "Bearer " + localStorage.getItem("token"),
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processUtilisateur3(_response);
    }

    protected async processUtilisateur3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param authorization (optional) 
     * @return Success
     */
    async notificationsAll(authorization: string | undefined): Promise<Notifications[]> {
        let url_ = this.baseUrl + "/Utilisateur/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processNotificationsAll(_response);
    }

    protected async processNotificationsAll(response: Response): Promise<Notifications[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Notifications.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<Notifications[]>(<any>null);
    }

    /**
     * @param authorization (optional) 
     * @return Success
     */
    async notificationsDelete(id: number, authorization: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Utilisateur/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processNotifications(_response);
    }

    protected async processNotifications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    async likeAll(): Promise<Utilisateur_Publisher[]> {
        let url_ = this.baseUrl + "/Utilisateur/like";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processLikeAll(_response);
    }

    protected async processLikeAll(response: Response): Promise<Utilisateur_Publisher[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Utilisateur_Publisher.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<Utilisateur_Publisher[]>(<any>null);
    }

    /**
     * @param authorization (optional) 
     * @param body (optional) 
     * @return Success
     */
    async like(authorization: string | undefined, body: CreateUtilisateur_Publisher | undefined): Promise<number> {
        let url_ = this.baseUrl + "/Utilisateur/like";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processLike(_response);
    }

    protected async processLike(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Success
     */
    async dislike(id: number): Promise<void> {
        let url_ = this.baseUrl + "/Utilisateur/like/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        const _response = await this.http.fetch(url_, options_);
        return await this.processLike2(_response);
    }

    protected async processLike2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            const _responseText = await response.text();
            return;
        } else if (status !== 200 && status !== 204) {
            const _responseText_1 = await response.text();
            return throwException("An unexpected server error occurred.", status, _responseText_1, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AuthenticateUtilisateur implements IAuthenticateUtilisateur {
    email?: string | undefined;
    motDePasse?: string | undefined;

    constructor(data?: IAuthenticateUtilisateur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.motDePasse = _data["motDePasse"];
        }
    }

    static fromJS(data: any): AuthenticateUtilisateur {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateUtilisateur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["motDePasse"] = this.motDePasse;
        return data; 
    }
}

export interface IAuthenticateUtilisateur {
    email?: string | undefined;
    motDePasse?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IAuthenticationResponse {
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class CreateMovies implements ICreateMovies {
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;

    constructor(data?: ICreateMovies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deck = _data["deck"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.name = _data["name"];
            this.release_date = _data["release_date"];
        }
    }

    static fromJS(data: any): CreateMovies {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMovies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deck"] = this.deck;
        data["description"] = this.description;
        data["image"] = this.image;
        data["name"] = this.name;
        data["release_date"] = this.release_date;
        return data; 
    }
}

export interface ICreateMovies {
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;
}

export class CreateMoviesAndPublisher implements ICreateMoviesAndPublisher {
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;
    publisher?: string | undefined;

    constructor(data?: ICreateMoviesAndPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deck = _data["deck"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.name = _data["name"];
            this.release_date = _data["release_date"];
            this.publisher = _data["publisher"];
        }
    }

    static fromJS(data: any): CreateMoviesAndPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMoviesAndPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deck"] = this.deck;
        data["description"] = this.description;
        data["image"] = this.image;
        data["name"] = this.name;
        data["release_date"] = this.release_date;
        data["publisher"] = this.publisher;
        return data; 
    }
}

export interface ICreateMoviesAndPublisher {
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;
    publisher?: string | undefined;
}

export class CreatePublishers implements ICreatePublishers {
    name?: string | undefined;
    image?: string | undefined;
    deck?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreatePublishers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.image = _data["image"];
            this.deck = _data["deck"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreatePublishers {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublishers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["image"] = this.image;
        data["deck"] = this.deck;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreatePublishers {
    name?: string | undefined;
    image?: string | undefined;
    deck?: string | undefined;
    description?: string | undefined;
}

export class CreateUtilisateur implements ICreateUtilisateur {
    nom?: string | undefined;
    prenom?: string | undefined;
    email?: string | undefined;
    motDePasse?: string | undefined;

    constructor(data?: ICreateUtilisateur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nom = _data["nom"];
            this.prenom = _data["prenom"];
            this.email = _data["email"];
            this.motDePasse = _data["motDePasse"];
        }
    }

    static fromJS(data: any): CreateUtilisateur {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUtilisateur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nom"] = this.nom;
        data["prenom"] = this.prenom;
        data["email"] = this.email;
        data["motDePasse"] = this.motDePasse;
        return data; 
    }
}

export interface ICreateUtilisateur {
    nom?: string | undefined;
    prenom?: string | undefined;
    email?: string | undefined;
    motDePasse?: string | undefined;
}

export class CreateUtilisateur_Publisher implements ICreateUtilisateur_Publisher {
    utilisateur_id?: number;
    publisher_id?: number;

    constructor(data?: ICreateUtilisateur_Publisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.utilisateur_id = _data["utilisateur_id"];
            this.publisher_id = _data["publisher_id"];
        }
    }

    static fromJS(data: any): CreateUtilisateur_Publisher {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUtilisateur_Publisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["utilisateur_id"] = this.utilisateur_id;
        data["publisher_id"] = this.publisher_id;
        return data; 
    }
}

export interface ICreateUtilisateur_Publisher {
    utilisateur_id?: number;
    publisher_id?: number;
}

export class Movies implements IMovies {
    id?: number;
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;

    constructor(data?: IMovies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deck = _data["deck"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.name = _data["name"];
            this.release_date = _data["release_date"];
        }
    }

    static fromJS(data: any): Movies {
        data = typeof data === 'object' ? data : {};
        let result = new Movies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deck"] = this.deck;
        data["description"] = this.description;
        data["image"] = this.image;
        data["name"] = this.name;
        data["release_date"] = this.release_date;
        return data; 
    }
}

export interface IMovies {
    id?: number;
    deck?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    name?: string | undefined;
    release_date?: string | undefined;
}

export class Notifications implements INotifications {
    id?: number;
    utilisateur_id?: number;
    movie_id?: number;

    constructor(data?: INotifications) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.utilisateur_id = _data["utilisateur_id"];
            this.movie_id = _data["movie_id"];
        }
    }

    static fromJS(data: any): Notifications {
        data = typeof data === 'object' ? data : {};
        let result = new Notifications();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["utilisateur_id"] = this.utilisateur_id;
        data["movie_id"] = this.movie_id;
        return data; 
    }
}

export interface INotifications {
    id?: number;
    utilisateur_id?: number;
    movie_id?: number;
}

export class Pages implements IPages {
    nb_Pages?: number;
    nb_Items?: number;

    constructor(data?: IPages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nb_Pages = _data["nb_Pages"];
            this.nb_Items = _data["nb_Items"];
        }
    }

    static fromJS(data: any): Pages {
        data = typeof data === 'object' ? data : {};
        let result = new Pages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nb_Pages"] = this.nb_Pages;
        data["nb_Items"] = this.nb_Items;
        return data; 
    }
}

export interface IPages {
    nb_Pages?: number;
    nb_Items?: number;
}

export class PaginationMovie implements IPaginationMovie {
    pages?: Pages;
    movies?: Movies[] | undefined;

    constructor(data?: IPaginationMovie) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pages = _data["pages"] ? Pages.fromJS(_data["pages"]) : <any>undefined;
            if (Array.isArray(_data["movies"])) {
                this.movies = [] as any;
                for (let item of _data["movies"])
                    this.movies!.push(Movies.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginationMovie {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationMovie();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pages"] = this.pages ? this.pages.toJSON() : <any>undefined;
        if (Array.isArray(this.movies)) {
            data["movies"] = [];
            for (let item of this.movies)
                data["movies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginationMovie {
    pages?: Pages;
    movies?: Movies[] | undefined;
}

export class PaginationPublisher implements IPaginationPublisher {
    pages?: Pages;
    publishers?: Publishers[] | undefined;

    constructor(data?: IPaginationPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pages = _data["pages"] ? Pages.fromJS(_data["pages"]) : <any>undefined;
            if (Array.isArray(_data["publishers"])) {
                this.publishers = [] as any;
                for (let item of _data["publishers"])
                    this.publishers!.push(Publishers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginationPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pages"] = this.pages ? this.pages.toJSON() : <any>undefined;
        if (Array.isArray(this.publishers)) {
            data["publishers"] = [];
            for (let item of this.publishers)
                data["publishers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginationPublisher {
    pages?: Pages;
    publishers?: Publishers[] | undefined;
}

export class Publishers implements IPublishers {
    id?: number;
    name?: string | undefined;
    image?: string | undefined;
    deck?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPublishers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.deck = _data["deck"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Publishers {
        data = typeof data === 'object' ? data : {};
        let result = new Publishers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["image"] = this.image;
        data["deck"] = this.deck;
        data["description"] = this.description;
        return data; 
    }
}

export interface IPublishers {
    id?: number;
    name?: string | undefined;
    image?: string | undefined;
    deck?: string | undefined;
    description?: string | undefined;
}

export class RefreshUtilisateur implements IRefreshUtilisateur {
    refreshToken?: string | undefined;

    constructor(data?: IRefreshUtilisateur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshUtilisateur {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshUtilisateur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IRefreshUtilisateur {
    refreshToken?: string | undefined;
}

export class Utilisateur implements IUtilisateur {
    id?: number;
    nom?: string | undefined;
    prenom?: string | undefined;
    email?: string | undefined;
    motDePasse?: string | undefined;

    constructor(data?: IUtilisateur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nom = _data["nom"];
            this.prenom = _data["prenom"];
            this.email = _data["email"];
            this.motDePasse = _data["motDePasse"];
        }
    }

    static fromJS(data: any): Utilisateur {
        data = typeof data === 'object' ? data : {};
        let result = new Utilisateur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nom"] = this.nom;
        data["prenom"] = this.prenom;
        data["email"] = this.email;
        data["motDePasse"] = this.motDePasse;
        return data; 
    }
}

export interface IUtilisateur {
    id?: number;
    nom?: string | undefined;
    prenom?: string | undefined;
    email?: string | undefined;
    motDePasse?: string | undefined;
}

export class Utilisateur_Publisher implements IUtilisateur_Publisher {
    id?: number;
    utilisateur_id?: number;
    publisher_id?: number;

    constructor(data?: IUtilisateur_Publisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.utilisateur_id = _data["utilisateur_id"];
            this.publisher_id = _data["publisher_id"];
        }
    }

    static fromJS(data: any): Utilisateur_Publisher {
        data = typeof data === 'object' ? data : {};
        let result = new Utilisateur_Publisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["utilisateur_id"] = this.utilisateur_id;
        data["publisher_id"] = this.publisher_id;
        return data; 
    }
}

export interface IUtilisateur_Publisher {
    id?: number;
    utilisateur_id?: number;
    publisher_id?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}